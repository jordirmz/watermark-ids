<!--
MIT License

Copyright (c) 2025 jordirmz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Code available in: https://github.com/jordirmz/watermark-ids.
Code adapted from Martin Aberastegue original code: https://github.com/Xyborg/datosargentinos.com.
New features: Run only in one file (index.html), blur feature is now a brush.
-->
<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparte documentos con marca de agua</title>
    <meta name="description" content="Comparte documentos agregando una marca de agua y ofuscando tus datos sensibles.">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Comparte documentos con marca de agua">
    <meta property="og:description"
        content="Comparte documentos agregando una marca de agua y ofuscando tus datos sensibles.">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'">
    <style>
        .transition-colors,
        .transition-transform {
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)
        }

        .comparison-slider img,
        .comparison-slider-wrapper>img {
            left: 0;
            height: 100%;
            object-fit: cover;
            pointer-events: none
        }

        *,
        ::after,
        ::before {
            box-sizing: border-box;
            border: 0 solid #e5e7eb;
            margin: 0;
            padding: 0
        }

        body {
            font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            line-height: 1.5;
            color: #1f2937;
            background: linear-gradient(135deg, #f0f7ff 0%, #fff7ed 100%);
            min-height: 100vh
        }

        :root {
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-brightness: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-contrast: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-grayscale: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-hue-rotate: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-invert: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-saturate: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-sepia: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-drop-shadow: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-blur: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-brightness: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-contrast: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-grayscale: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-hue-rotate: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-invert: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-opacity: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-saturate: var(--tw-empty,
                    /*!*/
                    /*!*/
                );
            --tw-backdrop-sepia: var(--tw-empty,
                    /*!*/
                    /*!*/
                )
        }

        .max-h-40 {
            max-height: 10rem
        }

        .opacity-75 {
            opacity: .75
        }

        .opacity-90 {
            opacity: .9
        }

        .select-none {
            user-select: none;
            -webkit-user-select: none
        }

        .pointer-events-none {
            pointer-events: none
        }

        .pointer-events-auto,
        .slider-handle {
            pointer-events: auto
        }

        .whitespace-nowrap {
            white-space: nowrap
        }

        .break-words {
            word-wrap: break-word
        }

        .break-all {
            word-break: break-all
        }

        .hidden {
            display: none
        }

        .block {
            display: block
        }

        .inline-block {
            display: inline-block
        }

        .flex {
            display: flex
        }

        .flex-col {
            flex-direction: column
        }

        .relative {
            position: relative
        }

        .absolute {
            position: absolute
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0
        }

        .top-1\/2 {
            top: 50%
        }

        .right-4 {
            right: 1rem
        }

        .w-full {
            width: 100%
        }

        .h-12,
        .w-12 {
            width: 3rem
        }

        .w-5 {
            width: 1.25rem
        }

        .h-20 {
            height: 5rem
        }

        .h-5 {
            height: 1.25rem
        }

        .h-2 {
            height: .5rem
        }

        .max-w-4xl {
            max-width: 56rem
        }

        .min-h-screen {
            min-height: 100vh
        }

        .transform {
            transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .-translate-y-1\/2 {
            --tw-translate-y: -50%;
            transform: var(--tw-transform)
        }

        .hover\:scale-105:hover {
            --tw-scale-x: 1.05;
            --tw-scale-y: 1.05;
            transform: var(--tw-transform)
        }

        .p-8 {
            padding: 2rem
        }

        .p-4 {
            padding: 1rem
        }

        .p-3 {
            padding: .75rem
        }

        .py-4 {
            padding-top: 1rem;
            padding-bottom: 1rem
        }

        .pt-8 {
            padding-top: 2rem
        }

        .pb-20 {
            padding-bottom: 5rem
        }

        .pr-16 {
            padding-right: 4rem
        }

        .mt-auto {
            margin-top: auto
        }

        .mt-12 {
            margin-top: 3rem
        }

        .mt-8 {
            margin-top: 2rem
        }

        .mt-6,
        .space-y-6>*+* {
            margin-top: 1.5rem
        }

        .mt-2 {
            margin-top: .5rem
        }

        .mb-16 {
            margin-bottom: 4rem
        }

        .mb-8 {
            margin-bottom: 2rem
        }

        .mb-6 {
            margin-bottom: 1.5rem
        }

        .mb-4 {
            margin-bottom: 1rem
        }

        .mb-2 {
            margin-bottom: .5rem
        }

        .mr-2 {
            margin-right: .5rem
        }

        .mx-auto {
            margin-left: auto;
            margin-right: auto
        }

        .space-y-4>*+* {
            margin-top: 1rem
        }

        .text-4xl {
            font-size: 2.25rem;
            line-height: 2.5rem
        }

        .text-2xl {
            font-size: 1.5rem;
            line-height: 2rem
        }

        .text-lg {
            font-size: 1.125rem;
            line-height: 1.75rem
        }

        .text-base {
            font-size: 1rem;
            line-height: 1.5rem
        }

        .text-sm {
            font-size: .875rem;
            line-height: 1.25rem
        }

        .font-bold {
            font-weight: 700
        }

        .font-semibold {
            font-weight: 600
        }

        .font-medium {
            font-weight: 500
        }

        .text-center {
            text-align: center
        }

        .text-white {
            color: #fff
        }

        .hover\:text-gray-800:hover,
        .text-gray-800 {
            color: #1f2937
        }

        .text-gray-600 {
            color: #4b5563
        }

        .text-gray-500 {
            color: #6b7280
        }

        .text-gray-400 {
            color: #9ca3af
        }

        .text-blue-600 {
            color: #2563eb
        }

        .text-purple-700 {
            color: #6d28d9
        }

        .bg-white {
            background-color: #fff
        }

        .bg-blue-50 {
            background-color: #eff6ff
        }

        .bg-purple-50 {
            background-color: #f5f3ff
        }

        .bg-purple-200 {
            background-color: #ddd6fe
        }

        .bg-gradient-to-br {
            background-image: linear-gradient(to bottom right, var(--tw-gradient-stops))
        }

        .from-gray-50 {
            --tw-gradient-from: #f9fafb;
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, #f9fafb)
        }

        .to-gray-100 {
            --tw-gradient-to: #f3f4f6
        }

        .border {
            border-width: 1px
        }

        .border-gray-300 {
            border-color: #d1d5db
        }

        .rounded-2xl {
            border-radius: 1rem
        }

        .rounded-lg {
            border-radius: .5rem
        }

        .shadow-xl {
            --tw-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .canvas-container,
        .comparison-slider-wrapper {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, .1), 0 2px 4px -1px rgba(0, 0, 0, .06);
            overflow: hidden
        }

        .cursor-pointer {
            cursor: pointer
        }

        .cursor-crosshair {
            cursor: crosshair
        }

        .appearance-none {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none
        }

        .transition-colors {
            transition-property: background-color, border-color, color, fill, stroke;
            transition-duration: .2s
        }

        .transition-transform {
            transition-property: transform;
            transition-duration: .3s
        }

        .duration-200 {
            transition-duration: .2s
        }

        .duration-300 {
            transition-duration: .3s
        }

        .focus\:ring-2:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-blue-500:focus {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgba(59, 130, 246, var(--tw-ring-opacity))
        }

        .focus\:border-transparent:focus {
            border-color: transparent
        }

        .items-center {
            align-items: center
        }

        .transition-all {
            transition: .3s ease-in-out
        }

        .custom-file-upload {
            border: 2px dashed #93c5fd;
            border-radius: .5rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: .3s;
            background-color: #f0f7ff
        }

        .custom-file-upload:hover {
            border-color: #3b82f6;
            background-color: #eff6ff
        }

        .step-transition {
            transition: opacity .5s ease-in-out, transform .5s ease-in-out
        }

        .step-enter {
            opacity: 0;
            transform: translateY(20px)
        }

        .step-enter-active {
            opacity: 1;
            transform: translateY(0)
        }

        .canvas-container {
            border-radius: .5rem
        }

        .gradient-button {
            background: linear-gradient(135deg, #2563eb 0, #3b82f6 100%);
            transition: transform .2s, box-shadow .2s;
            border: none;
            cursor: pointer
        }

        .gradient-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3)
        }

        .blur-button {
            background: linear-gradient(135deg, #f97316 0, #fb923c 100%)
        }

        .back-button {
            background: linear-gradient(135deg, #4b5563 0, #1f2937 100%)
        }

        .comparison-slider-wrapper {
            position: relative;
            width: 100%;
            max-width: 42rem;
            margin: 0 auto;
            border-radius: .5rem;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #fff;
            aspect-ratio: 1.6;
            overflow: hidden
        }

        .comparison-slider-wrapper>img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover
        }

        .comparison-slider {
            position: absolute;
            inset: 0;
            width: 50%;
            overflow: hidden;
            background-color: #fff
        }

        .comparison-slider img {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 100%;
            object-fit: cover
        }

        .slider-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            width: 6px;
            background: #abc3db;
            cursor: ew-resize;
            transform: translateX(-50%)
        }

        .slider-handle::before {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, .3)
        }

        .slider-handle::after {
            position: absolute;
            content: '';
            width: 24px;
            height: 24px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234A5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10 19l-7-7 7-7'/%3E%3Cpath d='M14 19l7-7-7-7'/%3E%3C/svg%3E") center/contain no-repeat
        }

        a {
            text-decoration: none
        }

        .card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1)
        }

        #downloadBtn {
            background: linear-gradient(135deg, #1d4ed8 0%, #3b82f6 100%) !important
        }

        #downloadBtn:hover {
            box-shadow: 0 4px 12px rgba(29, 78, 216, 0.3)
        }

        .highlight {
            background-color: #fff7ed;
            border-left: 4px solid #f97316;
            padding: 1rem;
            border-radius: .5rem
        }

        .faq-question {
            transition: all .3s ease
        }

        .faq-question:hover {
            transform: translateX(8px)
        }

        .crop-buttons-container {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 10px
        }

        .crop-buttons-container button {
            min-width: 140px;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: opacity .3s
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1rem;
            padding: .75rem;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(147, 197, 253, 0.2)
        }

        .tool-button {
            display: flex;
            align-items: center;
            gap: .5rem;
            padding: .75rem 1.25rem;
            border-radius: .75rem;
            font-weight: 500;
            transition: all .2s;
            border: 1px solid transparent;
            background: #fff;
            color: #4b5563;
            cursor: pointer;
            min-width: 120px;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05)
        }

        .tool-button:hover {
            background: #f8fafc;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1)
        }

        .tool-button.active {
            background: #dbeafe;
            border-color: #93c5fd;
            color: #1e3a8a
        }

        .tool-button svg {
            width: 1.5rem;
            height: 1.5rem
        }

        .controls-panel {
            background: #fff;
            padding: 1.5rem;
            border-radius: 1rem;
            margin-top: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(147, 197, 253, 0.2)
        }

        .controls-panel .buttons-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem
        }

        #enableCropBtn {
            background: #fae8ff;
            color: #9333ea;
            border-color: #e9d5ff
        }

        #enableCropBtn:hover,
        #enableCropBtn.active {
            background: #f3e8ff;
            border-color: #d8b4fe;
            color: #7e22ce
        }

        #enableBlurBtn {
            background: #f0fdf4;
            color: #15803d;
            border-color: #dcfce7
        }

        #enableBlurBtn:hover,
        #enableBlurBtn.active {
            background: #dcfce7;
            border-color: #86efac;
            color: #15803d
        }

        #nextToWatermarkBtn {
            background: #eff6ff;
            color: #2563eb;
            border-color: #dbeafe
        }

        #nextToWatermarkBtn:hover {
            background: #dbeafe;
            border-color: #93c5fd;
            color: #1d4ed8
        }

        #applyCropBtn {
            background: #f0fdf4;
            color: #065f46;
            border-color: #dcfce7
        }

        #applyCropBtn:hover {
            background: #dcfce7;
            border-color: #86efac;
            color: #15803d
        }

        #cancelCropBtn {
            background: #fef2f2;
            color: #7f1d1d;
            border-color: #fee2e2
        }

        #cancelCropBtn:hover {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #b91c1c
        }

        #undoBlurBtn {
            background: #fff7ed;
            color: #9a3412;
            border-color: #ffedd5
        }

        #undoBlurBtn:hover:not(:disabled) {
            background: #ffedd5;
            border-color: #fed7aa;
            color: #c2410c
        }

        #undoBlurBtn:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        .slider-control {
            display: flex;
            flex-direction: column;
            gap: .5rem;
            margin-bottom: 1.5rem;
            background: #f8fafc;
            padding: 1rem;
            border-radius: .75rem;
            border: 1px solid rgba(147, 197, 253, 0.2)
        }

        .slider-control input[type="range"] {
            width: 100%;
            height: .5rem;
            -webkit-appearance: none;
            appearance: none;
            background: #e2e8f0;
            border-radius: .25rem;
            outline: none
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 1.5rem;
            height: 1.5rem;
            background: #3b82f6;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: all .2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1)
        }

        .slider-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1)
        }

        .slider-control label {
            color: #4b5563;
            font-weight: 500
        }

        #blurInstructions {
            background: #fcefdc42;
            color: #805215;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center
        }

        @media (max-width: 640px) {
            .toolbar {
                gap: .75rem;
                padding: .75rem;
                flex-direction: column
            }

            .tool-button {
                width: 100%;
                padding: .75rem 1rem;
                justify-content: center
            }

            .tool-button svg {
                width: 1.25rem;
                height: 1.25rem
            }

            .controls-panel {
                padding: 1rem
            }

            .buttons-container {
                flex-direction: column;
                gap: .75rem
            }

            .buttons-container .tool-button {
                width: 100%
            }
        }
    </style>
</head>

<body class="flex flex-col items-center pt-8 pb-20">
    <div class="w-full max-w-4xl p-8 card rounded-2xl shadow-xl text-center mb-16 relative">
        <h1 class="text-4xl font-bold mb-8 text-gray-800">Comparte documentos con marca de agua</h1>
        <!-- Step 1: Upload and Text -->
        <div id="step1" class="space-y-6 step-transition">
            <label class="custom-file-upload block">
                <input type="file" id="imageInput" accept=".jpg,.jpeg,.png" class="hidden">
                <svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                    </path>
                </svg>
                <p class="text-lg text-gray-600">Arrastra tu imagen o haz clic aquí para subirla</p>
                <p class="text-sm text-gray-500 mt-2">Soporta: JPG y PNG</p>
            </label>
            <div class="relative">
                <div class="relative">
                    <input type="text" id="watermarkText" maxlength="60"
                        placeholder="Introduce el texto de la marca de agua (máx. 60 caracteres)"
                        class="w-full p-4 pr-16 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all text-center text-lg">
                    <span class="absolute right-4 top-1/2 -translate-y-1/2 text-sm text-gray-500">
                        <span id="charCount">0</span>/60
                    </span>
                </div>
                <p class="mt-2 text-sm text-gray-600 bg-blue-50 p-3 rounded-lg">
                    <strong>Consejo:</strong> Para mayor seguridad, incluye el nombre completo del destinatario y el
                    motivo específico (ej: "Para Juan Pérez - Validación de identidad en XYZ")
                </p>
            </div>

            <button id="nextToPreviewBtn"
                class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold hover:opacity-90">
                Siguiente
            </button>

            <div class="mt-4 text-center">
                <p class="text-sm text-gray-600">Tu documento se procesa localmente, sin enviar información a servidores
                    externos.</p>
            </div>
        </div>

        <!-- Step 2: Preview and Blur -->
        <div id="step2" class="hidden step-transition">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Editar imagen</h2>
                <div class="canvas-container">
                    <canvas id="originalCanvas" class="w-full cursor-crosshair"></canvas>
                </div>
            </div>

            <div class="toolbar">
                <button id="enableCropBtn" class="tool-button tooltip" data-tooltip="Recortar la imagen">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 4v16M17 4v16M3 8h18M3 16h18" />
                    </svg>
                    <span>Recortar imagen</span>
                </button>

                <button id="enableBlurBtn" class="tool-button tooltip" data-tooltip="Ocultar datos sensibles">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                    </svg>
                    <span>Ocultar datos</span>
                </button>

                <button id="nextToWatermarkBtn" class="tool-button tooltip"
                    data-tooltip="Continuar con la marca de agua">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Aplicar marca de agua</span>
                </button>
            </div>

            <div id="cropControls" class="controls-panel hidden">
                <p class="text-sm font-medium text-gray-700 mb-4 text-center">Arrastra las esquinas azules para ajustar
                    el área de recorte</p>
                <div class="buttons-container">
                    <button id="applyCropBtn" class="tool-button">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                        </svg>
                        <span>Aplicar</span>
                    </button>
                    <button id="cancelCropBtn" class="tool-button">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                        <span>Cancelar</span>
                    </button>
                </div>
            </div>
            <div id="blurInstructions" class="bg-blue-50 text-blue-700 p-4 rounded-lg mt-4 hidden">
                Haz clic y arrastra para ocultar áreas sensibles.<br /><span style="font-size: 0.8rem;">Ejemplo: Número
                    de trámite, Códigos de barras/QR, etc.</span>
            </div>
            <div id="blurControls" class="controls-panel hidden">

                <div class="slider-control">
                    <label for="cursorSize" class="text-sm font-medium text-gray-700">
                        Tamaño del cursor: <span id="cursorSizeValue">10</span>px
                    </label>
                    <input type="range" id="cursorSize" min="5" max="50" value="10">
                </div>

                <button id="undoBlurBtn" class="tool-button w-full" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
                    </svg>
                    <span>Deshacer última ofuscación</span>
                </button>
            </div>

        </div>

        <!-- Step 3: Final Result -->
        <div id="step3" class="hidden step-transition">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Resultado</h2>
                <div class="canvas-container">
                    <canvas id="canvas" class="w-full"></canvas>
                </div>
            </div>
            <button id="downloadBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold">
                Descargar imagen
            </button>
            <a href="#" id="startOverBtn"
                class="block mt-12 text-gray-600 hover:text-gray-800 text-base transition-colors duration-200">
                Volver a empezar
            </a>
        </div>
    </div>

    <script>
        /**
         * SAFE ID - Herramienta de Protección de DNI
         * 
         * Esta herramienta procesa las imágenes completamente en el navegador del usuario.
         * No se realiza ninguna carga de imágenes a servidores externos.
         * Todo el procesamiento de imágenes y datos se realiza localmente.
         */

        // Referencias a elementos del DOM para la interfaz de usuario
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const nextToPreviewBtn = document.getElementById('nextToPreviewBtn');
        const nextToWatermarkBtn = document.getElementById('nextToWatermarkBtn');
        const enableBlurBtn = document.getElementById('enableBlurBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const blurInstructions = document.getElementById('blurInstructions');

        /**
         * Configuración de los canvases para el procesamiento de imágenes
         * Se utilizan dos canvases:
         * - originalCanvas: mantiene la imagen original con las áreas ofuscadas
         * - canvas: muestra el resultado final con la marca de agua
         * 
         * willReadFrequently: true -> Optimiza el rendimiento para operaciones frecuentes de lectura de píxeles
         */
        const originalCanvas = document.getElementById('originalCanvas');
        const originalCtx = originalCanvas.getContext('2d', { willReadFrequently: true });
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        // Variables de estado para el control de la aplicación
        let img = new Image();           // Almacena la imagen cargada
        let painting = false;            // Controla el estado de pintado/ofuscación
        let blurEnabled = false;         // Controla si el modo ofuscación está activo

        /**
         * Configuración de calidad para el procesamiento de imágenes
         * Asegura que las imágenes mantengan la mejor calidad posible durante el procesamiento
         */
        originalCtx.imageSmoothingEnabled = true;
        originalCtx.imageSmoothingQuality = 'high';
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        /**
         * Sistema de contador de caracteres para la marca de agua
         * Limita y muestra la cantidad de caracteres ingresados (máximo 60)
         */
        const watermarkInput = document.getElementById('watermarkText');
        const charCount = document.getElementById('charCount');

        watermarkInput.addEventListener('input', function () {
            charCount.textContent = this.value.length;
        });

        /**
         * Manejador de carga de imágenes
         * - Valida el tipo de archivo (solo JPG y PNG)
         * - Procesa la imagen localmente sin enviarla a ningún servidor
         * - Muestra una vista previa en la interfaz
         */
        document.getElementById('imageInput').addEventListener('change', function (e) {
            if (e.target.files[0]) {
                const file = e.target.files[0];
                const fileLabel = this.parentElement.querySelector('p');

                // Validación de seguridad: solo permite formatos de imagen seguros
                const validTypes = ['image/jpeg', 'image/jpg', 'image/png'];
                if (!validTypes.includes(file.type)) {
                    alert('Por favor sube un archivo en formato JPG o PNG.');
                    this.value = ''; // Limpia el input por seguridad
                    return;
                }

                fileLabel.textContent = file.name;

                // Procesamiento local de la imagen para vista previa
                const reader = new FileReader();
                reader.onload = function (e) {
                    const previewImg = document.createElement('img');
                    previewImg.src = e.target.result;
                    previewImg.classList.add('mx-auto', 'mt-4', 'max-h-40', 'rounded-lg');

                    const existingPreview = fileLabel.parentElement.querySelector('img');
                    if (existingPreview) {
                        existingPreview.remove();
                    }

                    fileLabel.parentElement.appendChild(previewImg);
                };
                reader.readAsDataURL(file);
            }
        });

        /**
         * Sistema de transición entre pasos
         * Maneja la visibilidad y animaciones entre las diferentes etapas del proceso
         */
        function showStep(stepToShow) {
            const steps = [step1, step2, step3];

            for (const step of steps) {
                if (step === stepToShow) {
                    step.classList.remove('hidden');
                    step.classList.add('step-enter');
                    setTimeout(() => step.classList.add('step-enter-active'), 10);
                } else {
                    step.classList.add('hidden');
                    step.classList.remove('step-enter', 'step-enter-active');
                }
            }
        }

        /**
         * Cargador de imágenes seguro
         * - Procesa la imagen manteniendo las dimensiones originales
         * - No reduce la calidad de la imagen
         * - Mantiene el procesamiento en el dispositivo del usuario
         */
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                img = new Image();
                img.onload = function () {
                    // Mantiene las dimensiones originales para no perder calidad
                    originalCanvas.width = canvas.width = img.width;
                    originalCanvas.height = canvas.height = img.height;
                    originalCtx.drawImage(img, 0, 0, img.width, img.height);
                    ctx.drawImage(img, 0, 0, img.width, img.height);

                    // Ajusta el tamaño visual manteniendo la proporción
                    originalCanvas.style.width = canvas.style.width = '100%';
                    originalCanvas.style.height = canvas.style.height = 'auto';
                    originalCanvas.style.maxWidth = canvas.style.maxWidth = '100%';
                };
                img.onerror = function () {
                    alert('Error al cargar la imagen. Por favor intenta con otro archivo.');
                };
                img.src = e.target.result;
            };
            reader.onerror = function () {
                alert('Error al leer el archivo. Por favor intenta de nuevo.');
            };
            reader.readAsDataURL(file);
        }

        /**
         * Validación y procesamiento del paso inicial
         * Verifica que se hayan proporcionado todos los datos necesarios
         */
        nextToPreviewBtn.addEventListener('click', () => {
            const imageInput = document.getElementById('imageInput');
            const watermarkText = watermarkInput.value;

            if (!imageInput.files[0]) {
                alert('Por favor, sube una imagen primero.');
                return;
            }
            if (!watermarkText.trim()) {
                alert('Por favor, introduce el texto de la marca de agua.');
                return;
            }
            if (watermarkText.length > 60) {
                alert('El texto de la marca de agua debe tener 60 caracteres o menos.');
                return;
            }

            loadImage(imageInput.files[0]);
            showStep(step2);
        });

        /**
         * Sistema de recorte de imagen
         * Permite al usuario seleccionar y recortar una porción específica de la imagen
         */
        let cropEnabled = false;
        let cropBox = null;
        let originalImageData = null;
        let corners = [];

        // Elementos del DOM para el recorte
        const enableCropBtn = document.getElementById('enableCropBtn');
        const cropControls = document.getElementById('cropControls');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');

        function createCropBox() {
            cropBox = document.createElement('div');
            cropBox.style.position = 'absolute';
            cropBox.style.width = '100%';
            cropBox.style.height = '100%';
            cropBox.style.top = '0';
            cropBox.style.left = '0';
            cropBox.style.pointerEvents = 'none';

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.style.position = 'absolute';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.pointerEvents = 'none';

            // Set the SVG viewport
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('preserveAspectRatio', 'none');

            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            polygon.setAttribute('fill', 'rgba(6, 182, 212, 0.1)');
            polygon.setAttribute('stroke', '#06b6d4');
            polygon.setAttribute('stroke-width', '0.5');
            polygon.style.pointerEvents = 'none';
            svg.appendChild(polygon);
            cropBox.appendChild(svg);

            const canvasContainer = originalCanvas.parentElement;
            canvasContainer.style.position = 'relative';
            canvasContainer.appendChild(cropBox);

            // Calculate initial corner positions with padding relative to canvas size
            const rect = originalCanvas.getBoundingClientRect();
            const padding = Math.min(rect.width, rect.height) * 0.1; // 10% padding

            // Store corners in relative coordinates (0-1) for better scaling
            corners = [
                { x: padding / rect.width, y: padding / rect.height }, // Top-left
                { x: (rect.width - padding) / rect.width, y: padding / rect.height }, // Top-right
                { x: (rect.width - padding) / rect.width, y: (rect.height - padding) / rect.height }, // Bottom-right
                { x: padding / rect.width, y: (rect.height - padding) / rect.height } // Bottom-left
            ];

            // Create corner handles
            for (const [index, corner] of corners.entries()) {
                const handle = document.createElement('div');
                handle.className = 'corner-handle';
                handle.style.position = 'absolute';
                handle.style.width = '20px'; // Increased size for better touch
                handle.style.height = '20px'; // Increased size for better touch
                handle.style.backgroundColor = '#06b6d4';
                handle.style.border = '2px solid white';
                handle.style.borderRadius = '50%';
                handle.style.cursor = 'move';
                handle.style.zIndex = '10';
                handle.style.transform = 'translate(-50%, -50%)';
                handle.style.pointerEvents = 'auto';
                handle.style.touchAction = 'none'; // Prevent scrolling while dragging

                // Position the handle using relative coordinates
                handle.style.left = `${corner.x * 100}%`;
                handle.style.top = `${corner.y * 100}%`;

                // Mouse Events
                handle.addEventListener('mousedown', handleDragStart);

                // Touch Events
                handle.addEventListener('touchstart', handleDragStart, { passive: false });

                function handleDragStart(e) {
                    e.preventDefault(); // Prevent scrolling on mobile
                    e.stopPropagation();
                    const rect = originalCanvas.getBoundingClientRect();

                    function moveHandle(e) {
                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                        const x = Math.min(Math.max(0, (clientX - rect.left) / rect.width), 1);
                        const y = Math.min(Math.max(0, (clientY - rect.top) / rect.height), 1);

                        corners[index] = { x, y };
                        handle.style.left = `${x * 100}%`;
                        handle.style.top = `${y * 100}%`;

                        updatePolygon();
                    }

                    function stopMoving() {
                        document.removeEventListener('mousemove', moveHandle);
                        document.removeEventListener('mouseup', stopMoving);
                        document.removeEventListener('touchmove', moveHandle);
                        document.removeEventListener('touchend', stopMoving);
                    }

                    document.addEventListener('mousemove', moveHandle);
                    document.addEventListener('mouseup', stopMoving);
                    document.addEventListener('touchmove', moveHandle, { passive: false });
                    document.addEventListener('touchend', stopMoving);
                }

                cropBox.appendChild(handle);
            }

            updatePolygon();
        }

        function updatePolygon() {
            if (!cropBox) return;

            const polygon = cropBox.querySelector('polygon');
            if (polygon) {
                // Convert relative coordinates to SVG viewport coordinates (0-100)
                const pointsStr = corners.map(corner => {
                    const x = corner.x * 100;
                    const y = corner.y * 100;
                    return `${x},${y}`;
                }).join(' ');
                polygon.setAttribute('points', pointsStr);
            }
        }

        function disableCropMode() {
            cropEnabled = false;
            enableCropBtn.classList.remove('opacity-75');
            cropControls.classList.add('hidden');

            if (cropBox) {
                cropBox.remove();
                cropBox = null;
            }

            enableBlurBtn.style.display = 'inherit'; // Show blur button again after crop mode
        }

        function enableCropMode() {
            cropEnabled = true;
            enableCropBtn.classList.add('opacity-75');
            cropControls.classList.remove('hidden');
            originalImageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            createCropBox();

            // Disable blur mode if it's active
            if (blurEnabled) {
                blurEnabled = false;
                blurInstructions.style.display = 'none';
                blurControls.classList.add('hidden');
            }
            enableBlurBtn.style.display = 'none'; // Hide blur button during crop mode
        }

        function applyCrop() {
            if (!cropBox) return;

            // Calculate the bounds of the cropped area
            const points = corners.map(corner => ({
                x: corner.x * originalCanvas.width,
                y: corner.y * originalCanvas.height
            }));

            // Find the bounding box of the cropped area
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));

            // Calculate new dimensions
            const newWidth = maxX - minX;
            const newHeight = maxY - minY;

            // Create a temporary canvas for the original image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalCanvas.width;
            tempCanvas.height = originalCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the original image
            tempCtx.drawImage(originalCanvas, 0, 0);

            // Resize the original canvas to the new dimensions
            originalCanvas.width = newWidth;
            originalCanvas.height = newHeight;

            // Clear and set up the clipping path
            originalCtx.clearRect(0, 0, newWidth, newHeight);
            originalCtx.save();
            originalCtx.beginPath();

            // Adjust points relative to the new origin (minX, minY)
            let index = 0;
            for (const point of points) {
                const x = point.x - minX;
                const y = point.y - minY;

                if (index === 0) {
                    originalCtx.moveTo(x, y);
                } else {
                    originalCtx.lineTo(x, y);
                }

                index++;
            }

            originalCtx.closePath();
            originalCtx.clip();

            // Draw the cropped portion of the original image
            originalCtx.drawImage(tempCanvas, -minX, -minY);
            originalCtx.restore();

            // Update canvas style to maintain aspect ratio
            originalCanvas.style.width = '100%';
            originalCanvas.style.height = 'auto';
            originalCanvas.style.maxWidth = '100%';

            disableCropMode();
        }

        // Event listeners para el recorte
        enableCropBtn.addEventListener('click', () => {
            if (cropEnabled) {
                if (originalImageData) {
                    originalCtx.putImageData(originalImageData, 0, 0);
                }
                disableCropMode();
            } else {
                enableCropMode();
            }
        });

        applyCropBtn.addEventListener('click', applyCrop);
        cancelCropBtn.addEventListener('click', () => {
            if (originalImageData) {
                originalCtx.putImageData(originalImageData, 0, 0);
            }
            disableCropMode();
        });

        // Update the crop controls text
        const cropInstructions = document.querySelector('#cropControls p');
        cropInstructions.textContent = 'Arrastra las esquinas azules para ajustar el área de recorte.';

        /**
         * Sistema de control de ofuscación
         * Controla el tamaño del pincel de censura y la gestión de historial para deshacer
         */
        const cursorSize = document.getElementById('cursorSize');
        const cursorSizeValue = document.getElementById('cursorSizeValue');
        const blurControls = document.getElementById('blurControls');

        // Add state history tracking for undo
        let canvasStateHistory = [];
        let currentStateIndex = -1;
        const MAX_HISTORY_STATES = 20;
        let strokeInProgress = false;

        function saveCanvasState() {
            // Only save state if we're not in the middle of a stroke
            if (!strokeInProgress) {
                // Remove any states after current index if we branched
                canvasStateHistory = canvasStateHistory.slice(0, currentStateIndex + 1);

                // Save current canvas state
                const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);

                // If we reached max history, remove oldest state
                if (canvasStateHistory.length >= MAX_HISTORY_STATES) {
                    canvasStateHistory.shift();
                    currentStateIndex--;
                }

                canvasStateHistory.push(imageData);
                currentStateIndex++;

                // Enable/disable undo button based on history
                document.getElementById('undoBlurBtn').disabled = currentStateIndex <= 0;
            }
        }

        function undoBlur() {
            if (currentStateIndex > 0) {
                currentStateIndex--;
                const previousState = canvasStateHistory[currentStateIndex];
                originalCtx.putImageData(previousState, 0, 0);

                // Update undo button state
                document.getElementById('undoBlurBtn').disabled = currentStateIndex <= 0;
            }
        }

        cursorSize.addEventListener('input', function () {
            cursorSizeValue.textContent = this.value;
        });

        /**
         * Control del modo ofuscación
         * Activa/desactiva la capacidad de ofuscar áreas sensibles
         */
        enableBlurBtn.addEventListener('click', () => {
            blurEnabled = !blurEnabled;
            blurInstructions.style.display = blurEnabled ? 'block' : 'none';
            blurControls.classList.toggle('hidden');
            enableBlurBtn.classList.toggle('opacity-75');

            if (blurEnabled) {
                // Initialize state history when enabling blur mode
                canvasStateHistory = [];
                currentStateIndex = -1;
                saveCanvasState(); // Save initial state

                if ('ontouchstart' in globalThis) {
                    blurInstructions.innerHTML = 'Toca y arrastra para ocultar áreas sensibles, luego aplica la marca de agua<br /><span style="font-size: 0.8rem;">Ejemplo: Número de trámite, Códigos de barras/QR, Información innecesaria.</span>';
                }
            }
        });

        // Add undo button event listener
        document.getElementById('undoBlurBtn').addEventListener('click', undoBlur);

        // Navegación entre pasos
        nextToWatermarkBtn.addEventListener('click', () => {
            showStep(step3);
            applyWatermark();
        });

        startOverBtn.addEventListener('click', () => {
            location.reload();
        });

        /**
         * Sistema de descarga segura
         * Genera la imagen final en el dispositivo del usuario
         * No se realiza ninguna carga a servidores externos
         */
        document.getElementById('downloadBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'resultado.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        /**
         * Sistema de ofuscación interactivo
         * Implementa eventos de mouse y touch para permitir al usuario
         * ofuscar áreas específicas de la imagen de forma interactiva
         */

        // Eventos de mouse para ofuscación
        originalCanvas.addEventListener('mousedown', (event) => {
            if (blurEnabled) {
                painting = true;
                blurAtMouse(event);
            }
        });

        originalCanvas.addEventListener('mouseup', () => {
            painting = false;
            if (strokeInProgress) {
                strokeInProgress = false;
                saveCanvasState();
            }
        });
        originalCanvas.addEventListener('mousemove', (event) => {
            if (painting && blurEnabled) {
                blurAtMouse(event);
            }
        });

        // Eventos táctiles para ofuscación en dispositivos móviles
        originalCanvas.addEventListener('touchstart', (event) => {
            if (blurEnabled) {
                event.preventDefault(); // Prevenir scroll mientras se ofusca
                painting = true;
                blurAtTouch(event);
            }
        });

        originalCanvas.addEventListener('touchend', (event) => {
            event.preventDefault();
            painting = false;
            if (strokeInProgress) {
                strokeInProgress = false;
                saveCanvasState();
            }
        });

        originalCanvas.addEventListener('touchmove', (event) => {
            if (painting && blurEnabled) {
                event.preventDefault(); // Prevenir scroll mientras se ofusca
                blurAtTouch(event);
            }
        });

        /**
         * Funciones de cálculo de posición para ofuscación
         * Convierten las coordenadas de pantalla a coordenadas de canvas
         * considerando el escalado y posición del elemento
         */
        function blurAtMouse(event) {
            // Obtener las dimensiones y posición actual del canvas
            const rect = originalCanvas.getBoundingClientRect();
            // Calcular factores de escala para mantener precisión
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            // Convertir coordenadas del mouse a coordenadas del canvas
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            applyRedactBrush(x, y);
        }

        function blurAtTouch(event) {
            // Obtener las dimensiones y posición actual del canvas
            const rect = originalCanvas.getBoundingClientRect();
            // Calcular factores de escala para mantener precisión
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            // Obtener el primer punto de contacto
            const touch = event.touches[0];
            // Convertir coordenadas táctiles a coordenadas del canvas
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            applyRedactBrush(x, y);
        }

        /**
         * Pincel de censura
         * En vez de desenfocar, pinta un círculo sólido encima de la zona.
         * De esta forma los píxeles originales quedan sobrescritos.
         * @param {number} x - Coordenada X del centro del pincel
         * @param {number} y - Coordenada Y del centro del pincel
         */
        function applyRedactBrush(x, y) {
            // Solo guardamos estado antes del primer trazo continuo
            if (!strokeInProgress) {
                saveCanvasState();
                strokeInProgress = true;
            }

            const radius = Number.parseInt(cursorSize.value);

            originalCtx.save();
            originalCtx.globalCompositeOperation = 'source-over';

            // Color de censura: negro sólido (puedes cambiarlo o hacerlo configurable)
            originalCtx.fillStyle = '#000000';

            // Pincel circular
            originalCtx.beginPath();
            originalCtx.arc(x, y, radius, 0, Math.PI * 2);
            originalCtx.fill();

            originalCtx.restore();
        }

        /**
         * Sistema de marca de agua
         * Aplica una marca de agua visible y persistente a la imagen
         * El proceso es irreversible y se realiza en múltiples capas
         * para prevenir la eliminación de la marca de agua
         */
        function applyWatermark() {
            // Obtener el texto de la marca de agua
            const watermarkText = watermarkInput.value;

            // Ajustar dimensiones del canvas final
            canvas.width = originalCanvas.width;
            canvas.height = originalCanvas.height;

            // Limpiar el canvas y dibujar la imagen procesada
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalCanvas, 0, 0);

            // Mantener proporción de aspecto en la visualización
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            canvas.style.maxWidth = '100%';

            // Convertir la imagen a escala de grises para mejor visibilidad de la marca de agua
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = data[i + 1] = data[i + 2] = avg;
            }
            ctx.putImageData(imageData, 0, 0);

            // Calcular tamaño de fuente adaptativo
            const minFontSize = 8;
            const maxFontSize = 22;
            const baseFontSize = Math.min(canvas.width, canvas.height) / 40;
            const fontSize = Math.min(maxFontSize, Math.max(minFontSize, baseFontSize));

            // Configurar estilo del texto
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';

            // Calcular espaciado para el patrón de marca de agua
            const textWidth = ctx.measureText(watermarkText).width;
            const horizontalSpacing = textWidth * 1.2;
            const verticalSpacing = fontSize * 1.2;

            // Aplicar transformación para patrón diagonal
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(-Math.PI / 6);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            // Calcular área de cobertura para la marca de agua
            const diagonal = Math.hypot(canvas.width, canvas.height);
            const startX = -diagonal / 2;
            const startY = -diagonal / 2;
            const endX = diagonal * 1.5;
            const endY = diagonal * 1.5;

            /**
             * Función para crear el efecto ondulado en el texto
             * Añade variación y complejidad a la marca de agua
             * para dificultar su eliminación
             * @param {string} text - Texto a dibujar
             * @param {number} x - Posición X base del texto
             * @param {number} y - Posición Y base del texto
             * @param {number} amplitude - Amplitud de la onda
             * @param {number} frequency - Frecuencia de la onda
             */
            const drawWavyText = (text, x, y, amplitude, frequency) => {
                const characters = text.split('');
                const prevAlign = ctx.textAlign;
                ctx.textAlign = 'left';  // Alineación izquierda para cálculo preciso de posición
                let currentX = x - (textWidth / 2);
                const baselineY = y;

                for (const char of characters) {
                    const charWidth = ctx.measureText(char).width;
                    const waveX = currentX + (charWidth / 2);
                    const yOffset = amplitude * Math.sin(frequency * waveX + baselineY * 0.05);
                    const xOffset = amplitude * 0.3 * Math.cos(frequency * waveX + baselineY * 0.05);

                    // Capa de sombra para mejorar legibilidad
                    ctx.globalAlpha = 0.1;
                    ctx.fillText(char, currentX + xOffset + 1, baselineY + yOffset + 1);

                    // Capa principal del texto
                    ctx.globalAlpha = 0.35;
                    ctx.fillText(char, currentX + xOffset, baselineY + yOffset);

                    currentX += charWidth * 1.1;
                }
                ctx.textAlign = prevAlign;

            };

            // Paleta de colores para la marca de agua
            // Colores semi-transparentes para mejor integración visual
            const colors = [
                'rgba(230, 110, 110, 0.7)',  // Light red
                'rgba(140, 171, 111, 0.7)',  // Olive green
                'rgba(230, 110, 110, 0.7)',  // Light red
                'rgba(140, 171, 111, 0.7)',  // Olive green
                'rgba(124, 128, 194, 0.7)',  // Grayish blue
                'rgba(186, 85, 211, 0.7)',   // Purple
                'rgba(255, 165, 0, 0.7)',    // Orange
                'rgba(75, 0, 130, 0.7)',     // Indigo
                'rgba(64, 224, 208, 0.7)',   // Turquoise
                'rgba(255, 20, 147, 0.7)',   // Deep pink
                'rgba(255, 215, 0, 0.7)',    // Gold
                'rgba(0, 128, 128, 0.7)',    // Teal
                'rgba(219, 112, 147, 0.7)',  // Pale pink
                'rgba(106, 90, 205, 0.7)',   // Slate blue
                'rgba(255, 99, 71, 0.7)',    // Tomato
                'rgba(147, 112, 219, 0.7)',  // Medium purple
                'rgba(60, 179, 113, 0.7)',   // Medium sea green
                'rgba(238, 130, 238, 0.7)',  // Violet
                'rgba(218, 165, 32, 0.7)',   // Dark gold
                'rgba(72, 209, 204, 0.7)',   // Medium turquoise
                'rgba(199, 21, 133, 0.7)',   // Medium magenta
                'rgba(255, 140, 0, 0.7)'     // Dark orange
            ];

            // Aplicar el patrón de marca de agua en toda la imagen
            for (let y = startY; y < endY; y += verticalSpacing) {
                // Alternar el offset horizontal en cada fila para crear patrón entrelazado
                let offsetX = (Math.floor(y / verticalSpacing) % 2) * (horizontalSpacing / 2);

                for (let x = startX + offsetX; x < endX; x += horizontalSpacing) {
                    // Parámetros de la onda para el texto
                    const amplitude = fontSize * 0.8;
                    const frequency = 0.04;
                    // Seleccionar color aleatorio para cada instancia del texto
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    drawWavyText(watermarkText, x, y, amplitude, frequency);
                }
            }

            // Restaurar el contexto del canvas y la opacidad
            ctx.restore();
            ctx.globalAlpha = 1;
        }
    </script>
</body>

</html>